## SQL-инъекции

### Защита от SQL-инъекций в Eloquent ORM

По умолчанию, Eloquent ORM Laravel защищает от SQL-инъекций путем параметризации запросов и использования привязок SQL. Например, рассмотрим следующий запрос:

```php
use App\Models\User;

User::where('email', $email)->get();
```

Приведенный выше код выполняет следующий запрос:

```sql
select * from `users` where `email` = ?
```

Таким образом, даже если `$email` является ненадежными данными ввода пользователя, вы защищены от атак SQL-инъекций.

### Необработанные SQL-запросы

Laravel также предлагает использовать необработанные выражения запросов и необработанные запросы для создания сложных запросов или запросов, специфичных для базы данных, которые не поддерживаются "из коробки".

Хотя это отлично для гибкости, вы должны всегда быть осторожны и всегда использовать привязки данных SQL для таких запросов. Рассмотрим следующий запрос:

```php
use Illuminate\Support\Facades\DB;
use App\Models\User;

User::whereRaw('email = "'.$request->input('email').'"')->get();
DB::table('users')->whereRaw('email = "'.$request->input('email').'"')->get();
```

Обе строки кода фактически выполняют один и тот же запрос, который уязвим к SQL-инъекциям, поскольку запрос не использует привязки SQL для ненадежных данных ввода пользователя.

Вышеуказанный код выполняет следующий запрос:

```sql
select * from `users` where `email` = "значение параметра email запроса"
```

Всегда помните использовать привязки SQL для данных запроса. Мы можем исправить код выше, сделав следующую модификацию:

```php
use App\Models\User;

User::whereRaw('email = ?', [$request->input('email')])->get();
```

Мы даже можем использовать именованные привязки SQL, как показано ниже:

```php
use App\Models\User;

User::whereRaw('email = :email', ['email' => $request->input('email')])->get();
```

### SQL-инъекции по именам столбцов

Вы никогда не должны разрешать пользовательские данные влиять на имена столбцов, на которые ссылаются ваши запросы.

Следующие запросы могут быть уязвимы к SQL-инъекциям:

```php
use App\Models\User;

User::where($request->input('colname'), 'somedata')->get();
User::query()->orderBy($request->input('sortBy'))->get();
```

Важно отметить, что хотя Laravel имеет встроенные функции, такие как оборачивание имен столбцов для защиты от SQL-инъекций, некоторые базы данных (в зависимости от версий и конфигураций) могут быть уязвимы, поскольку привязка имен столбцов не поддерживается базами данных.

По крайней мере, это может привести к уязвимости массового присваивания вместо SQL-инъекций, потому что вы, возможно, ожидали определенный набор значений столбцов, но поскольку они не проверяются здесь, пользователь может свободно использовать и другие столбцы.

Всегда проверяйте пользовательский ввод для таких ситуаций, как п

оказано ниже:

```php
use App\Models\User;

$request->validate(['sortBy' => 'in:price,updated_at']);
User::query()->orderBy($request->validated()['sortBy'])->get();
```

### Правила валидации подверженные SQL-инъекциям

Некоторые правила валидации могут предоставлять имена столбцов базы данных. Такие правила уязвимы к SQL-инъекциям так же, как и SQL-инъекции по именам столбцов, потому что они конструируют запросы аналогичным образом.

Например, следующий код может быть уязвим:

```php
use Illuminate\Validation\Rule;

$request->validate([
'id' => Rule::unique('users')->ignore($id, $request->input('colname'))
]);
```

За кулисами, приведенный выше код запускает следующий запрос:

```php
use App\Models\User;

$colname = $request->input('colname');
User::where($colname, $request->input('id'))->where($colname, '<>', $id)->count();
```

Поскольку имя столбца диктуется вводом пользователя, это аналогично SQL-инъекции по именам столбцов.
